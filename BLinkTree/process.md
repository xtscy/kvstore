## blink实现

### 并发设计

先解决分裂时,搜索操作的冲突
使用原子变量的元信息


这里搜索的时候直接使用元信息,
当确定在哪个节点时,再用读锁锁当前节点
找是否存在某个键
如何确定呢,使用high_key和right_sibling
这里直接判断high_key,如果小于那么就是当前节点
或者是当前节点的子节点
然后也就需要搜索,当搜索时再获取读锁,
这样使锁的影响最小化


那么这里的insert
需要分裂时是否需要去锁住current和new_root呢

split涉及数据的移动和元信息的修改

是否可以在移动数据的时候再对数据改变的两个节点进行加锁
这样就可以减小大量的锁竞争

那么是否可以呢?
当进入到split,如果数据没有移动,那么相当于原树的形状没有改变
只要没有加锁进行数据移动那么相当于没有执行split

在数据移动前进行元信息的修改工作,当元信息设置完毕,再设置分裂标志
那么这里实际上在分裂标志和加锁语句中间隔非常短,或者说分裂标志设置完后就是加锁
这里在设置元信息时有其他线程对于当前节点的读取操作,那么绝大部分应该判断的都是当前节点未处于分裂状态
那么把当前节点判断成未分裂状态是否可行呢
如果是未分裂,那么就走普通的搜索判断
并且这里搜索的时候是不会加读锁的
如果是分裂就走high_key和subling
从正确性上是一定可以的,因为就算我查找的是正在插入的数据,那么只能说明插入操作慢,从而导致查找的数据还不存在

所以这里判断成未分裂也是可以的

那么这里的split标志就只有在设置完元信息后，并且在锁锁定前，
有线程来访问该节点，此时才会看到分裂状态，并且使用元信息
只有在这种情况下会直接使用元信息
这里只是达到了把锁的影响最小化
如果判断未在分裂状态的话
也可以使用元信息，因为分裂最先改变的也是元信息

那么这里会不会分裂改变的元信息，使得搜素到当前节点
读到的元信息是分裂时的元信息呢，是否会有问题
这里分裂的标志是否需要
这里标志可以区分如果不是分裂就使用原本的搜素方法
那如果未分裂也使用元信息，那么相当于不需要分裂标志了
那是否存在并发问题



那么这里要如何去设计呢
是进入split直接设置分裂标志吗,但是元信息是否可用呢?









