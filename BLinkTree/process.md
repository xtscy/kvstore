## blink实现

### 并发设计

先解决分裂时,搜索操作的冲突
使用原子变量的元信息


这里搜索的时候直接使用元信息,
当确定在哪个节点时,再用读锁锁当前节点
找是否存在某个键
如何确定呢,使用high_key和right_sibling
这里直接判断high_key,如果小于那么就是当前节点
或者是当前节点的子节点
然后也就需要搜索,当搜索时再获取读锁,
这样使锁的影响最小化


那么这里的insert
需要分裂时是否需要去锁住current和new_root呢

split涉及数据的移动和元信息的修改

是否可以在移动数据的时候再对数据改变的两个节点进行加锁
这样就可以减小大量的锁竞争

那么是否可以呢?
当进入到split,如果数据没有移动,那么相当于原树的形状没有改变
只要没有加锁进行数据移动那么相当于没有执行split

在数据移动前进行元信息的修改工作,当元信息设置完毕,再设置分裂标志
那么这里实际上在分裂标志和加锁语句中间隔非常短,或者说分裂标志设置完后就是加锁
这里在设置元信息时有其他线程对于当前节点的读取操作,那么绝大部分应该判断的都是当前节点未处于分裂状态
那么把当前节点判断成未分裂状态是否可行呢
如果是未分裂,那么就走普通的搜索判断
并且这里搜索的时候是不会加读锁的
如果是分裂就走high_key和subling
从正确性上是一定可以的,因为就算我查找的是正在插入的数据,那么只能说明插入操作慢,从而导致查找的数据还不存在

所以这里判断成未分裂也是可以的

那么这里的split标志就只有在设置完元信息后，并且在锁锁定前，
有线程来访问该节点，此时才会看到分裂状态，并且使用元信息
只有在这种情况下会直接使用元信息
这里只是达到了把锁的影响最小化
如果判断未在分裂状态的话
也可以使用元信息，因为分裂最先改变的也是元信息

那么这里会不会分裂改变的元信息，使得搜素到当前节点
读到的元信息是分裂时的元信息呢，是否会有问题
这里分裂的标志是否需要
这里标志可以区分如果不是分裂就使用原本的搜素方法
那如果未分裂也使用元信息，那么相当于不需要分裂标志了
那是否存在并发问题3
这里如果使用标志，并且在初始化元信息但是还没标记正在分裂时
这里如果search不使用元信息，就使用普通的遍历搜索
如果要遍历那么必然就需要加读锁，这样在遍历期间才不会有例如写操作来更改当前节点，从而导致线程并发问题

那么这里就有两种设计
1. 在元信息设置成功后再设置分裂标志，如果是非分裂状态那么就不使用元信息，而是使用普通的遍历搜索即需要读锁
2. 第二种就是一进入分裂就最先设置分裂状态，但是这里有一个问题，也就是另外一个线程如何search的问题，这里search如果直接使用元信息行不行？ 如果使用未初始化完的元信息，可能当前的high_key和right_sibling对应性并不正确,那么必然就有线程安全问题，我这里不管先设置哪一个，如果另一个没有设置完那么就会有可能跳到错误的一个节点， **所以这里如果要使用元信息并且为了强正确性，那么肯定需要同步，这里可以用无锁来同步，再用一个标志来表示是否设置完成。这里涉及到两个原子变量，一个进入split标志一个元信息设置完成标志**

先实现第一种，就是直接加锁
[%d{%H:%M:%S}][%t][%c][%f:%l][%p]%T%m%n


那么这里要如何去设计呢
是进入split直接设置分裂标志吗,但是元信息是否可用呢?


current:
1. 增加remove的precursor和successor的锁逻辑
    1完成了precursor和successor的锁逻辑
2. split_child的锁设计
    当前先弄split_child
3. 修改insert的加锁逻辑
    现在开始实现这个
3. 修改remove的加锁逻辑
4. 增加remove的fill_node填充节点及其内部加锁逻辑

先完成第一个

fix:
    1.
btree_remove调用的remove_node
需要判断返回值,因为可能原本有值删除,但由于是
optimistic的contain所以值在删除的时候可能不存在
那么remove没删除成功则返回true
在remove_node中增加判断逻辑
      ```
bool ret = remove_node(root, key, tree->t);
    // 根节点键个数为0，降低树高度
    // 这里叶子节点
    if (root->num_keys == 0 && !root->is_leaf) {
        // 这里如果是最后一6个键,没有child，tree->root将会指向NULL
        // 根节点的最后一个键下沉，说明有children,那么root指向child
        tree->root = root->children[0];
        destroy_node(root);
    }
        ```


这里对于precursor的调用
     这里有可能前面的删除操作正好使得叶子节点为空，那么就需要去具体判断remove的逻辑 
     这里remove在调用remove_node删除之后,才会去
     并且删除操作不会锁定之前的节点，
     这里remove对于叶子节点还没有执行完
     那么叶子节点是被写锁lock住的
     这里在parent的位置下去前,
     会保证下一个节点的key是满足最小数量的
     所以这里在叶子节点的删除一定是安全操作
     所以这里不用判断叶子节点是否为空(存在)
     这里路径上经过的都保证是可删除的,如果下面某个节点不可删除那么parent减少一个节点
     由于节点保证最小键个数,所以减少一个
     然后最多也就是上面的parent节点变得不可删除
     然后当前节点可删除,也就是叶子节点就算删除也必然有效,树的高度的降低是在根节点
     在叶子节点删除后remove_node返回
     在btree_remove最后判断根节点键个数是否是0
     从而来更改root指针,来降低树的高度

     **即在多线程下precusor中直接获取和使用child指针,如果child指针在remove也是安全的,如果child指针在insert也是安全的,至少child存在**

     当前进度，precursor可以直接访问child无需判断child为空的情况
     下一步检查加锁逻辑，和最后的孩子节点的lock不解锁


2. **split_child**
    atomic_bool meta_valid;
    虽然这里当更改元信息在最开始就让meta失效
    但是可能有其他的读线程
    这里使用元信息也是为了尽可能的不去阻塞读操作
    所以这里split_child的设计又和读操作进行深度捆绑了
    那先看看读操作
    btree_contains是实现乐观判断
    这里就先实现contains
    1. contains
    这里有几种策略
    只使用元信息，如果不可用循环


3. **修改insert的逻辑**
这里在处理根节点满的代码时，
这里去判断值在左边还是右边,不需要在内部对当前current解锁
这样如果刚好在左边就少1次解锁
如果是右边再去锁右边然后解锁左边
这里由于有new_root所以可以直接访问左边
但是这里split_child的内部逻辑最好梳理清楚

这里在根节点不满的else里再去写不满时的对crrent的加锁逻辑






